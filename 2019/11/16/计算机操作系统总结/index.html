<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="执念の博客" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="计算机操作系统的知识点总结归纳 这个是自己看着王道课程做的，因为本学期上了操作系统，正好考研这个科目是肯定会考的，所以记录下来，学精学细致一点。 转载请注明出处，花了近一个月的时间，请尊重私人创作。">
<meta name="keywords" content="理论基础,操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机操作系统总结">
<meta property="og:url" content="https:&#x2F;&#x2F;zh1n1an.github.io&#x2F;2019&#x2F;11&#x2F;16&#x2F;%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93&#x2F;index.html">
<meta property="og:site_name" content="执念の博客">
<meta property="og:description" content="计算机操作系统的知识点总结归纳 这个是自己看着王道课程做的，因为本学期上了操作系统，正好考研这个科目是肯定会考的，所以记录下来，学精学细致一点。 转载请注明出处，花了近一个月的时间，请尊重私人创作。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;55ecd77e-3b61-4c58-8154-2738e440a224-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;31094513-27da-489f-83e2-679249779491-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;55f8adb3-61f9-45ef-a17c-3d98785afc6d-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;fa3cd65e-0e0a-4a63-8d0d-7b71a9bdc492-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;d6f30db4-5cc2-408d-9fa1-30f6aa5dc884-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;b104c720-efc9-4ca9-8ae4-c291e7980bb5-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;af030385-7417-4cfd-9208-d6168aeae2e8-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;8ab50f02-dc34-4899-8716-6dbe5122e2ee-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;e5250d2e-c638-406e-804a-96a2a21bc0dc-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;3c27e6a7-449f-456b-bad7-2e0725354a9e-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;3c27e6a7-449f-456b-bad7-2e0725354a9e-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;6a9d5069-b1e5-4034-a471-094b9354db67-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;28f75f64-0fde-41ac-a8c6-d506c7d0bfea-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;1cb36c6c-d101-472e-8251-dd953d64f25c-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;9608743a-27cd-4bdc-97a0-898a789df1ec-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;bcb39d24-bdbb-43da-8489-b89256081b54-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;36cb80c0-f86f-4e50-a883-b83e6e702b04-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;be33a6c5-d117-4af9-a553-6702ee98ed62-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;bb9bb2bc-85c2-4e47-af47-222ffe82df03-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;c28e5560-8b0f-40b2-97ca-4fac12625654-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;24dbb90c-d226-4a3a-9903-c2e51aad1e19-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;310b0bb2-f6d0-46e9-aa06-2b87e4b8c727-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;8da6133a-f2d8-4ccd-b287-247217e4578d-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;794c32db-97a3-46b3-98ec-db1e7c5dbf6e-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;53c2225b-6e86-4b61-9ab3-ce1cf6292ecf-4379197.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;a1a683b4-5cc0-4615-8ade-536e05f53bc5-4379197.jpg">
<meta property="og:updated_time" content="2019-12-18T11:51:06.824Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;img.mubu.com&#x2F;document_image&#x2F;55ecd77e-3b61-4c58-8154-2738e440a224-4379197.jpg">

<link rel="canonical" href="https://zh1n1an.github.io/2019/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>计算机操作系统总结 | 执念の博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">执念の博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">15</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">23</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">25</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zh1n1an.github.io/2019/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/head/avatar.JPG">
      <meta itemprop="name" content="执灬念">
      <meta itemprop="description" content="没有一颗心，会因为追求梦想而受伤。当你真心渴望某样东西时，整个宇宙都会来帮忙。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="执念の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机操作系统总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-16 15:45:00" itemprop="dateCreated datePublished" datetime="2019-11-16T15:45:00+08:00">2019-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-18 19:51:06" itemprop="dateModified" datetime="2019-12-18T19:51:06+08:00">2019-12-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">理论基础</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>计算机操作系统的知识点总结归纳</p>
<p>这个是自己看着王道课程做的，因为本学期上了操作系统，正好考研这个科目是肯定会考的，所以记录下来，学精学细致一点。</p>
<p>转载请注明出处，花了近一个月的时间，请尊重私人创作。</p>
<a id="more"></a>

<ul>
<li><p>第一章</p>
<ul>
<li>作为用户和计算机硬件之间的接口<ul>
<li>提供的功能<ul>
<li>命令接口<ul>
<li>联机命令接口：说一句做一句</li>
<li>脱机命令接口：说一堆做一堆</li>
</ul>
</li>
<li>程序接口：“系统调用”，用户通过程序间接使用</li>
<li>GUI：图形化操作界面</li>
</ul>
</li>
<li>目标<ul>
<li>方便用户使用</li>
</ul>
</li>
</ul>
</li>
<li>资源的管理者<ul>
<li>处理机管理</li>
<li>存储器管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
</li>
<li>操作系统的特征<ul>
<li>并发：每一个小时换一个女朋友约会<ul>
<li>并行：和一号二号女朋友一起约会</li>
</ul>
</li>
<li>共享<ul>
<li>互斥共享：一个时间段，只允许一个进程访问</li>
<li>同时共享：运行一个时间段内运行多个进程“同时（就像并发）”对它们访问</li>
<li>没有并发那么就没有共享</li>
</ul>
</li>
<li>虚拟：<ul>
<li>虚拟存储器基础：空分复用技术</li>
<li>虚拟处理器：时分复用技术</li>
</ul>
</li>
<li>异步：资源有限，进程执行不是一贯到底，而是走走停停</li>
</ul>
</li>
<li>OS发展与分类<ul>
<li>手工操作阶段：（纸带）用户独占全机，人机速度矛盾，资源利用率低</li>
<li>批处理阶段<ul>
<li>单道批处理系统：脱机输入/输入技术（磁带），并监督程序（操作系统的雏形）负责控制作业输入、输出</li>
<li>多道批处理系统（操作系统开始出现）：计算机一次在磁带中读入多道程序，程序并发执行（没有人机交互功能）</li>
</ul>
</li>
<li>分时操作系统：不能优先处理一些紧急任务</li>
<li>实时操作系统<ul>
<li>硬实时操作系统：必须在绝对严格规定时间内完成（发射导弹）</li>
<li>软实时操作系统：能接受偶尔违反时间规定（12306）</li>
</ul>
</li>
</ul>
</li>
<li>OS的运行机制和体系结构<ul>
<li>运行机制<ul>
<li>两种指令<ul>
<li>特权指令</li>
<li>非特权指令</li>
</ul>
</li>
<li>两种处理器状态<ul>
<li>核心态（只能执行非特权指令）（普通用户）</li>
<li>用户态（可以特权and非特权指令）（管理员）</li>
</ul>
</li>
<li>两种程序<ul>
<li>内核程序（可以执行特权and非特权指令在核心态）</li>
<li>应用程序（只能执行非特权指令在用户态）</li>
</ul>
</li>
</ul>
</li>
<li>操作系统内核（内核是计算机配置的底层软件）<ul>
<li>时钟管理</li>
<li>中断处理</li>
<li>原语<ul>
<li>是一种特殊的程序</li>
<li>处于操作系统最底层，是最接近硬件的部分</li>
<li>这种程序的运行具有原子性——其运行只能一气呵成，不可中断</li>
<li>运行世界较短、调用频繁</li>
</ul>
</li>
<li>对系统资源进行管理的功能<ul>
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ul>
</li>
</ul>
</li>
<li>操作系统体系结构<ul>
<li>大内核<ul>
<li>将操作系统的主要功能模块都作为系统内核，运行在核心态</li>
<li>高性能</li>
<li>内核代码庞大，结构混乱，难以维护</li>
</ul>
</li>
<li>微内核<ul>
<li>只把最基本的功能保留在内核</li>
<li>内核功能少，结构清晰，方便维护</li>
<li>需要频繁地在核心态和用户态之间切换，性能低</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>中断和异常<ul>
<li>中断（广义）<ul>
<li>中断发生时，CPU立即进入核心态 （因为只有核心态，操作系统才能使用特权指令）</li>
<li>用户态——核心态，只能通过中断进行转换<ul>
<li>陷入指令，仅能在用户态下进行，为的就是产生内中断从而进入核心态</li>
</ul>
</li>
<li>核心态——用户态只需要一个特权指令，将程序状态字地标志位改成“用户态”</li>
<li>内中断（异常，例外，陷入）<ul>
<li>来源CPU内部</li>
</ul>
</li>
<li>外中断（中断）<ul>
<li>来源CPU外部</li>
<li>1、每条指令结束后，CPU检查是否有外部中断信号</li>
<li>2、若有则保护被中断地CPU环境</li>
<li>3、根据中断信号类型转入相应地中断处理程序</li>
<li>4、回复原进程地CPU环境并退出中断，返回原进程继续往下执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>系统调用 分类<ul>
<li>设备管理</li>
<li>文件管理</li>
<li>进程控制</li>
<li>进程通信</li>
<li>内存管理</li>
</ul>
</li>
</ul>
</li>
<li><p>第二章</p>
<ul>
<li><p>进程（动态的，进程实体的运行过程）</p>
<ul>
<li>进程实体（静态的，进程是数据集合）<ul>
<li>PCB（进程控制块）是进程存在的唯一标志<ul>
<li>操作系统通过PCB来管理进程，因此PCB中应该包含操作系统对其进行管理所需的各种信息</li>
<li>进程描述信息<ul>
<li>进程标识符PID<ul>
<li>用于区分不同的进程是唯一的</li>
</ul>
</li>
<li>用户标识符UID<ul>
<li>此进程所属的用户是谁</li>
</ul>
</li>
<li>进程控制和管理信息<ul>
<li>进程当前状态</li>
<li>进程优先级</li>
</ul>
</li>
<li>资源分配清单<ul>
<li>程序段指针</li>
<li>数据段指针</li>
<li>键盘</li>
<li>鼠标</li>
</ul>
</li>
<li>处理机相关信息<ul>
<li>各种寄存器的值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数据段<ul>
<li>程序代码存入在此</li>
</ul>
</li>
<li>程序段<ul>
<li>运行时使用、产生的运算数据等等</li>
</ul>
</li>
</ul>
</li>
<li>进程的组织方式<ul>
<li>连接方式<ul>
<li>按照进程状态将PCB分为多个队列<ul>
<li>执行指针</li>
<li>就绪队列指针</li>
<li>阻塞队列指针</li>
</ul>
</li>
<li>操作系统持有指向各个队列的指针</li>
</ul>
</li>
<li>索引方式<ul>
<li>根据进程状态的不同，建立几张索引表<ul>
<li>执行指针</li>
<li>就绪表指针<ul>
<li>指向各个PCB</li>
</ul>
</li>
<li>阻塞表指针<ul>
<li>指向各个PCB</li>
</ul>
</li>
</ul>
</li>
<li>操作系统持有指向各个索引表的指针</li>
</ul>
</li>
</ul>
</li>
<li>进程的特征<ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性<ul>
<li>进程是能独立运行、独立获得资源、独立接受调度的基本单位（进程是资源分配接受调度的基本单位）</li>
</ul>
</li>
<li>异步性<ul>
<li>各进程以不可预知的速度向前推进，可能导致运行结果的不确定性</li>
</ul>
</li>
<li>结构性</li>
</ul>
</li>
</ul>
</li>
<li><p>进程的……</p>
<ul>
<li>状态<ul>
<li>运行状态<ul>
<li>其他所需资源：Yes</li>
<li>CPU：Yes</li>
<li>占有CPU，并在CPU上运行<ul>
<li>在单核处理机环境下，每一个时刻最多只有一个进程处于运行态</li>
</ul>
</li>
</ul>
</li>
<li>就绪状态<ul>
<li>其他所需资源：Yes</li>
<li>CPU：No</li>
<li>已经具备运行条件，但由于没有空闲CPU，而展示不能进行（万事俱备，只欠CPU）</li>
</ul>
</li>
<li>阻塞状态<ul>
<li>其他所需资源：No</li>
<li>CPU：No</li>
<li>因等待某一事件而展示不能运行（为了提高CPU利用率）</li>
</ul>
</li>
<li>创建状态<ul>
<li>进程正在被创建，操作系统为进程分配资源、初始化PCB</li>
</ul>
</li>
<li>终止状态<ul>
<li>进程正在从系统撤销，操作系统会回收进程拥有的资源、撤销PCB</li>
</ul>
</li>
</ul>
</li>
<li>进行状态间的转换<ul>
<li>创建态&gt;&gt;&gt;就绪态<ul>
<li>系统完成创建进程相关的工作</li>
</ul>
</li>
<li>就绪态&gt;&gt;&gt;运行态<ul>
<li>进程被调度</li>
</ul>
</li>
<li>运行态&gt;&gt;&gt;就绪态<ul>
<li>时间片到，或CPU被其他高优先级的进程抢占</li>
</ul>
</li>
<li>运行态&gt;&gt;&gt;阻塞态<ul>
<li>是一种进程自身做出主动的行为，等待系统资源分配</li>
</ul>
</li>
<li>阻塞态&gt;&gt;&gt;就绪态<ul>
<li>是一种被动行为，所需要的其他（除处理机之外）资源就绪后，等待事件发生</li>
</ul>
</li>
<li>运行态&gt;&gt;&gt;终止态<ul>
<li>进程运行结束or运行国产中遇到不可修复的错误</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>进程控制</p>
<ul>
<li>基本概念<ul>
<li>什么是进程控制？<ul>
<li>就是要实现进程状态的转换</li>
</ul>
</li>
<li>如何实现进程控制<ul>
<li>用“原语”实现<ul>
<li>原语的特点！！！不允许被中断！！！</li>
<li>原语采用关中断and开中断的指令实现</li>
<li>原语所需要进行的事情<ul>
<li>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）<ul>
<li>所有的进程控制原语一定都会修改进程的状态标志</li>
<li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li>
<li>某进程开始运行的前必然要恢复其运行环境</li>
</ul>
</li>
<li>将PCB插入合适队列</li>
<li>分配/回收资源</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程控制相关的原语<ul>
<li>进程的创建<ul>
<li>创建原语<ul>
<li>申请空白PCB</li>
<li>为新进程分配所需资源</li>
<li>初始化PCB</li>
<li>将PCB插入就绪队列</li>
</ul>
</li>
<li>引起进程创建的时间<ul>
<li>用户登录<ul>
<li>分时系统中，用户登录成功，系统会为其建立一个新的进程</li>
</ul>
</li>
<li>作业调度<ul>
<li>多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li>
</ul>
</li>
<li>提供服务<ul>
<li>用户向操作系统提出某些请求时，会建立一个进程处理该请求</li>
</ul>
</li>
<li>应用请求<ul>
<li>由用户进程主动请求创建一个子进程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程的终止<ul>
<li>撤销原语<ul>
<li>从PCB集合中找到终止进程的PCB</li>
<li>若程序正在运行，则立即剥夺CPU，将CPU分配给其他进程</li>
<li>终止其所有子进程</li>
<li>将该进程拥有的资源归还给父进程或操作系统</li>
<li>删除PCB</li>
</ul>
</li>
<li>引起进程终止的事件<ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ul>
</li>
</ul>
</li>
<li>进程的阻塞<ul>
<li>阻塞原语<ul>
<li>找到要阻塞的进程对于的PCB</li>
<li>保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li>
<li>将PCB插入相应的等待序列</li>
</ul>
</li>
<li>引起阻塞的事件<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待相互合作的其他进程完成工作</li>
</ul>
</li>
</ul>
</li>
<li>进程的唤醒<ul>
<li>唤醒原语<ul>
<li>在事件等待队列中找到PCB</li>
<li>将PCB从等待队列中移除，设置进程为就绪态</li>
<li>将PCB插入就绪队列</li>
</ul>
</li>
<li>引起进程唤醒的事件<ul>
<li>等待的事件发生</li>
</ul>
</li>
</ul>
</li>
<li>进程的切换<ul>
<li>切换原语<ul>
<li>将运行环境信息存入PCB</li>
<li>PCB移入相应的队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>根据PCB恢复新进程所需的运行环境</li>
</ul>
</li>
<li>引起进程切换的事件<ul>
<li>当前进程时间片到</li>
<li>有更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>进程通信：进程之间的信息交换</p>
<ul>
<li>共享存储<ul>
<li>基于数据结构的共享（低级通信方式）</li>
<li>基于存储区的共享（高级通信方式 ）</li>
</ul>
</li>
<li>消息传递：操作系统提供的“发送消息/接受消息”两个原语进行数据交换，类似于计网中的报文<ul>
<li>直接通信方式<ul>
<li>消息直接挂到接收方的消息队列里</li>
</ul>
</li>
<li>间接通信方式<ul>
<li>消息先发到中间体（信箱）</li>
</ul>
</li>
</ul>
</li>
<li>管道通信<ul>
<li>只能采用半双工通信，某一时间段内只能实现单向传输，如果要实现双向同时通信，则需要设置两个管道</li>
<li>各进程要互斥地访问管道</li>
<li>管道写满的时候，写进程write()系统调用将被阻塞。管道变空，此时读进程read()系统调用将被阻塞</li>
<li>如果没写满，就不允许读，如果没读空，就不允许写</li>
<li>数据一旦被读出，就会被管道丢弃，所以读进程最多只能有一个，否则会有读错数据的情况</li>
</ul>
</li>
</ul>
</li>
<li><p>线程、多线程模型</p>
<ul>
<li>什么是线程，为什么要引入线程？<ul>
<li>轻量级进程</li>
<li>现在线程是基本的CPU执行单元也是程序执行流的最小单位</li>
<li>增加并发度</li>
<li>线程是程序执行流的最小单位</li>
</ul>
</li>
<li>引入线程机制后，有什么变化？<ul>
<li>资源分配、调度<ul>
<li>传统进程机制中，进程是资源分配、调度的基本单位</li>
<li>引入线程后，进程是（打印机）资源分配的基本单位、而线程是调度的基本单位</li>
</ul>
</li>
<li>并发性<ul>
<li>传统进程机制中，只能进程并发</li>
<li>引入线程后，各线程间也能并发，提升了并发度</li>
</ul>
</li>
<li>系统开销<ul>
<li>传统的进程间并发，需要切换进程的运行环境，系统开销很大</li>
<li>线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小</li>
<li>总的来说，引入线程后，并发所带来的系统开销减少</li>
</ul>
</li>
</ul>
</li>
<li>线程有哪些重要的属性<ul>
<li>线程是处理机调度的单位</li>
<li>多CPU中，各个线程可占用不同的CPU</li>
<li>每个线程都有一个线程ID、线程控制块（TCB）</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同进程间共享进程的资源</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程的切换</li>
<li>不同进程中的线程切换，会引起进程切换（废话0.0）</li>
<li>切换同进程内的线程，系统开销很小</li>
<li>切换进程，系统开销很大</li>
</ul>
</li>
<li>线程的实现方式<ul>
<li>用户级线程<ul>
<li>线程管理工作都有应用程序负责，线程切换可以在用户态下完成</li>
</ul>
</li>
<li>内核级线程<ul>
<li>操作系统内核视角看到的线程</li>
</ul>
</li>
<li>重点重点重点！！！！！<ul>
<li>内核级线程次啊是处理机分配的单位，因为操作系统只“看得见”内核级线程</li>
</ul>
</li>
</ul>
</li>
<li>多线程模型<ul>
<li>多对一模型<ul>
<li>并发度低</li>
<li>优点：进程管理开销小</li>
<li>缺点：一个线程的阻塞会导致整个进程被阻塞</li>
</ul>
</li>
<li>一对一模型<ul>
<li>并发度高</li>
<li>优点：进程管理开销大</li>
<li>缺点：各个线程可分配到多核处理机并行执行，并发度高</li>
</ul>
</li>
<li>多对多模型<ul>
<li>集二者之所长</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>处理机调度</p>
<ul>
<li>基本概念<ul>
<li>按照一定的算法选择一个进程</li>
</ul>
</li>
<li>三个层次<ul>
<li>高级调度（作业调度）<ul>
<li>外存&gt;&gt;&gt;内存（面向作业）</li>
<li>作业调入内存</li>
</ul>
</li>
<li>中级调度（内存调度）<ul>
<li>外存&gt;&gt;&gt;内存（面向进程）</li>
<li>暂时不能运行的进程会调至外存等待：挂起</li>
<li>挂起：PCB不会一起调到外存，而是会常驻内存，PCB会放到挂机队列中</li>
</ul>
</li>
<li>低级调度（进程调度）<ul>
<li>内存&gt;&gt;&gt;CPU</li>
<li>就绪调度到执行状态</li>
</ul>
</li>
</ul>
</li>
<li>三层调度的联系、对比</li>
<li>补充知识<ul>
<li>进程的“挂起态”</li>
<li>七状态模型<ul>
<li>添加了就绪挂起</li>
<li>添加了阻塞挂起</li>
<li>阻塞挂起可以转换到就绪挂起</li>
<li>挂起和阻塞的区别<ul>
<li>两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像到外存去了，而阻塞状态下的进程映像还在内存中，但是PCB都全在内存中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>进程调度的……</p>
<ul>
<li>时机<ul>
<li>什么时候需要进程调度？<ul>
<li>进程主动放弃处理机<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>进程主动请求阻塞</li>
</ul>
</li>
<li>进程被动放弃处理机<ul>
<li>分配给进程的时间片用完</li>
<li>有更紧急的事情要处理（如I/O中断）</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ul>
</li>
<li>什么时候不能进行进程调度？<ul>
<li>不能进行进程调度与切换的状态的情况<ul>
<li>在处理中断的过程中</li>
<li>在操作系统内核程序临界区中（仅仅是内核程序临界区不行，普通程序临界区，比如打印机就可以）</li>
<li>在原子操作过程中（原语）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>切换与过程<ul>
<li>“狭义的调度”与“切换”的区别<ul>
<li>狭义的调度<ul>
<li>选中一个要运行的进程，这个进程可以是刚刚被暂停执行的进程（就比如中断后恢复），也可以是另一个进程（进程切换）</li>
</ul>
</li>
<li>进程切换：一个进程让出处理机，另一个进程占用处理机（不属于侠义的调度）</li>
<li>广义进程调度<ul>
<li>包含了选择一个进程和进程切换两个步骤</li>
</ul>
</li>
</ul>
</li>
<li>进程切换的过程需要做什么？<ul>
<li>对原来运行进程的各种数据进行保存</li>
<li>对新的进程各种数据恢复</li>
</ul>
</li>
</ul>
</li>
<li>方式<ul>
<li>非剥夺调度方式（非抢占式）<ul>
<li>只允许进程主动放弃处理机</li>
</ul>
</li>
<li>剥夺调度方式（抢占式）<ul>
<li>有一个更重要or更紧迫的进程需要使用处理机，则立即暂停正在执行的程序，将处理机分配给更重要的那个进程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>调度算法的评价指标</p>
<ul>
<li>CPU利用率<ul>
<li>利用率=（忙碌时间/总时间）</li>
</ul>
</li>
<li>系统吞吐量<ul>
<li>单位时间内完成作业的数量</li>
<li>系统吞吐量=（总共完成了多少道作业/总共花了多少时间）</li>
</ul>
</li>
<li>周转时间<ul>
<li>周转时间、平均周转时间<ul>
<li>周转时间=作业完成时间-作业提交时间</li>
<li>平均周转时间=各个作业的周转时间之和/作业数</li>
</ul>
</li>
<li>带权周转时间、评价带权周转时间<ul>
<li>带权周转时间=作业周转时间/作业实际运行的时间=（作业完成时间-作业提交时间）/作业实际运行的时间<ul>
<li>必然&gt;=1，并且数值越小越好</li>
</ul>
</li>
<li>各个作业的带权周转时间之和/作业数</li>
</ul>
</li>
</ul>
</li>
<li>等待时间<ul>
<li>处于等待处理机状态时间之和</li>
<li>对于进程来说，等待时间就是进程建立后等待被服务（等待I/O设备也是在被服务的，所以不算入等待时间）的时间之和</li>
<li>对于作业来说，等待时间就是建立进程后的等待时间，还要加上作业在外存后备队列中的等待时间</li>
</ul>
</li>
<li>响应时间<ul>
<li>提出请求到首次响应的时间</li>
</ul>
</li>
</ul>
</li>
<li><p>调度算法一</p>
<ul>
<li>用于早期的批处理系统，不适合用于交互性系统的算法</li>
<li>饥饿状态<ul>
<li>某进程/作业长期得不到服务</li>
</ul>
</li>
<li>先来先服务（FCFS）（First Come First Serve）<ul>
<li>按照作业/进程到达的先后顺序进行服务</li>
<li>非抢占式的算法</li>
<li>优点：公平、算法实现非常简单</li>
<li>缺点：对长作业有利、对短作业不利</li>
<li>不会导致饥饿</li>
<li>没有考虑作业的运行时间，所以对短作业不友好</li>
</ul>
</li>
<li>短作业优先（SJF Short Job First）<ul>
<li>最短的作业/进程优先得到服务</li>
<li>非抢占式（SJF、STF），也有抢占式版本（最短剩余时间优先算法SRTN）</li>
<li>非抢占式，就判断就绪队列，谁所用的时间少就服务谁</li>
<li>抢占式，当一个作业到达就要判断，谁剩余的时间少就服务谁</li>
<li>优点：“最短的”平均等待时间。平均周转时间</li>
<li>缺点：不公平，对短作业有利，对长作业不利</li>
<li>会导致饥饿</li>
<li>没有考虑等待时间，所以对长作业不友好</li>
</ul>
</li>
<li>高响应比优先（HRRN Highest Response Ratio Next）<ul>
<li>综合考虑作业/进程的等待时间和要求服务的时间</li>
<li>在每次调度时先计算各个作业/进程的响应比，现在相应比最高的作业/进程为其服务<ul>
<li>相应比=（等待时间+要求服务时间）/要求服务时间</li>
</ul>
</li>
<li>是非抢占式的算法</li>
<li>优点：综合了考虑等待时间和运行时间</li>
<li>不会饥饿</li>
</ul>
</li>
</ul>
</li>
<li><p>调度算法二</p>
<ul>
<li>适用于交互式系统</li>
<li>时间片轮转调度算法（RR Round-Robin）<ul>
<li>按照各个进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。</li>
<li>用于进程调度</li>
<li>抢占式算法（由时钟中断来通知CPU时间片已到）</li>
<li>时间片不能大，否则就变成了先来先服务，不能太小，否则切换进程的时间开销过大</li>
<li>优点：公平，响应快，适用于分时操作系统</li>
<li>缺点：由于高频率的进程切换，因而有一定的开销，不区分任务的紧急程度</li>
<li>不会导致饥饿</li>
</ul>
</li>
<li>优先级调度算法<ul>
<li>调度时选择优先级最高的作业/进程</li>
<li>有非抢占式和抢占式</li>
<li>非抢占式：进程运行完，才判断调度，若优先级相同，先来先服务</li>
<li>抢占式：就绪队列发生改变就要判断优先级，优先级高的抢占优先级低的处理机，若优先级相同，先来先服务</li>
<li>优先级<ul>
<li>系统进程优先级 高于 用户进程</li>
<li>前台进程优先级 高于 后台进程</li>
<li>操作系统更偏好于I/O进程<ul>
<li>I/O设备和CPU可以并行工作，如果让I/O繁忙型进程优先运行的花，则越有可能让I/O设备尽早地投入工作</li>
</ul>
</li>
<li>优点：可灵活挑战对各种作业/进程地偏好程度</li>
<li>缺点：若源源不断地有高优先级进程到来，可能会饥饿</li>
<li>会导致饥饿</li>
</ul>
</li>
</ul>
</li>
<li>多级反馈队列调度算法<ul>
<li>对其他调度算法的折中权衡</li>
<li>是抢占式的算法</li>
<li>算法（<a href="https://www.bilibili.com/video/av70156862/?p=16" target="_blank" rel="noopener">https://www.bilibili.com/video/av70156862/?p=16</a> 32分钟的位置，看例子）<ul>
<li>设置多级就绪队列，各个队列的优先级从高到低，时间片从大到小</li>
<li>新进程到达时，先进入第一级队列，，按FCFS原则排队等待被分配的时间片，若时间片用完，进程还未结束，则进入下一级队列的队尾，如果此时是最下级的队列了，则重新返回最下级队列队尾。</li>
<li>只有k级队列为空，才会为k+1级队头的进程分配时间片，突然出现高优先级的，会直接抢占</li>
<li>被抢占处理机的进程会放回原级队列队尾</li>
</ul>
</li>
<li>优点：FCFS的优点+RR的优点+SPF的优点+（避免进程更改自己的实际服务时间作假）</li>
<li>会导致饥饿</li>
</ul>
</li>
</ul>
</li>
<li><p>同步、互斥问题</p>
<ul>
<li>什么是进程同步<ul>
<li>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要子啊某些位置上协调他们的工作次序而产生的制约的关系。进程间的直接制约关系就是源于他们直接的相互合作</li>
</ul>
</li>
<li>什么是进程互斥<ul>
<li>把一个时间段内只允许一个进程使用的资源成为临界资源</li>
<li>对于临界资源的访问，必须互斥地进行。互斥，亦称间接制约广西，进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。<ul>
<li>临界区是进程中访问临界资源的代码段。</li>
<li>进入区和退出区是负责实现互斥的代码段。</li>
<li>临界区也可称为“临界段”</li>
</ul>
</li>
</ul>
</li>
<li>实现进程互斥的原则<ul>
<li>空闲让进</li>
<li>忙着等待</li>
<li>有限等待（防止饥饿）</li>
<li>让权等待（放弃处理机，防止进程忙等待）</li>
</ul>
</li>
</ul>
</li>
<li><p>进程互斥的软件实现方法</p>
<ul>
<li><p>单标志法</p>
<ul>
<li><p>标志（int turn）表示当前运行进入临界区的进程号</p>
</li>
<li><p>再由运行完的进程在退出区去将turn值修改使得第另一个 进程能进入</p>
</li>
<li><p><img src="https://img.mubu.com/document_image/55ecd77e-3b61-4c58-8154-2738e440a224-4379197.jpg" alt="img"></p>
</li>
<li><p>违背了空闲让进原则，比如临界区空闲，但是P0没访问前P1不允许访问</p>
</li>
</ul>
</li>
<li><p>双标志先检查</p>
<ul>
<li><p><img src="https://img.mubu.com/document_image/31094513-27da-489f-83e2-679249779491-4379197.jpg" alt="img"></p>
</li>
<li><p>因为两个程序是并行的 所以很可能 1语句执行完就执行5语句而不是2语句导致冲突</p>
</li>
<li><p>违背了慢则等待</p>
</li>
</ul>
</li>
<li><p>双标志后检查</p>
<ul>
<li><p><img src="https://img.mubu.com/document_image/55f8adb3-61f9-45ef-a17c-3d98785afc6d-4379197.jpg" alt="img"></p>
</li>
<li><p>违背了空闲让进、有限等待</p>
</li>
</ul>
</li>
<li><p>进程的异步性去查看是否可能出现问题 即手动操作尝试</p>
</li>
<li><p>Peterson算法</p>
<ul>
<li><p>如果双方都争着想进入临界区，那可以让进程“孔融让梨”，主动让对方先使用临界区</p>
</li>
<li><p><img src="https://img.mubu.com/document_image/fa3cd65e-0e0a-4a63-8d0d-7b71a9bdc492-4379197.jpg" alt="img"></p>
</li>
<li><p>比较前两个算法算是最好的，但是依然不够好，未遵循让权等待，并且while循环会一直进行。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>进程互斥的硬件实现方法</p>
<ul>
<li><p>中断屏蔽方法</p>
<ul>
<li>关中断</li>
<li>临界区</li>
<li>开中断</li>
<li>优点：简单、高效</li>
<li>缺点：不适用于多处理机（容易出现两个处理机上的两个进程同时访问临界区）；只适用于内核进程，不适用于用户进程。</li>
</ul>
</li>
<li><p>TestAndSet（TS指令/TSL指令）</p>
<ul>
<li><p>TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。</p>
</li>
<li><p><img src="https://img.mubu.com/document_image/d6f30db4-5cc2-408d-9fa1-30f6aa5dc884-4379197.jpg" alt="img"></p>
</li>
<li><p>保证检查and上锁可以一气呵成不被打断</p>
</li>
<li><p>优点：实现简单，无需像软件实现方法那样严格检查是否由逻辑漏洞；；适用于多处理及环境</p>
</li>
<li><p>缺点：不满足“让权等待”，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“满等”</p>
</li>
</ul>
</li>
<li><p>Swap指令（XCHG指令）</p>
<ul>
<li><p>也是用硬件实现的</p>
</li>
<li><p><img src="https://img.mubu.com/document_image/b104c720-efc9-4ca9-8ae4-c291e7980bb5-4379197.jpg" alt="img"></p>
</li>
<li><p>逻辑上和TSL没有很大的区别</p>
</li>
<li><p>所以优点和缺点见TSL一样的</p>
</li>
</ul>
</li>
<li><p>我个人理解：Swap指令和TSL指令逻辑上都是，不管Lock有没有被锁，先上锁了，再判断刚刚的Lock是不是被锁着。即先上锁，再检查。（不知道对不对）</p>
</li>
</ul>
</li>
<li><p>信号量机制（巨TM重要！！！！！！！）</p>
<ul>
<li><p>之前的实现方法，都无法实现“让权等待”</p>
</li>
<li><p>信号量</p>
<ul>
<li>信号量其实就是一个变量（可以是一个整数，也可也是更复杂的记录型变量），来表示系统中某种资源的数量</li>
<li>原语，执行只能一气呵成不能被中断</li>
<li>一对原语：wait(S)原语和signal(S)原语</li>
<li>wait、signal原语通常称为P、V操作（来自荷兰语0.0），做题长把wait(S)、signal(S)写成P(S)、V(S)</li>
</ul>
</li>
<li><p>整型信号量</p>
<ul>
<li><p>用整数表示系统资源数量（只能进行三种操作）</p>
<ul>
<li>初始化</li>
<li>P操作 “–”</li>
<li>V操作 “++”</li>
</ul>
</li>
<li><p><img src="https://img.mubu.com/document_image/af030385-7417-4cfd-9208-d6168aeae2e8-4379197.jpg" alt="img"></p>
</li>
<li><p>存在的问题：还是不满足“让权等待”</p>
</li>
</ul>
</li>
<li><p>记录型信号量（<a href="https://www.bilibili.com/video/av70156862/?p=20" target="_blank" rel="noopener">https://www.bilibili.com/video/av70156862/?p=20</a> 18分钟的时候）</p>
<ul>
<li><p><img src="https://img.mubu.com/document_image/8ab50f02-dc34-4899-8716-6dbe5122e2ee-4379197.jpg" alt="img"></p>
</li>
<li><p>多了一个主动阻塞的语句block，从而进入阻塞队列，释放处理机，等待着被唤醒，所以实现了让权等待</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>信号量机制实现</p>
<ul>
<li><p>信号量机制实现进程互斥（信号量为1）</p>
<ul>
<li><p>可以这么去理解</p>
<ul>
<li>临界区资源就只有一个，例如仅有一个打印机资源</li>
<li>互斥信号量mutex，初值设置为1</li>
<li>就类似于，资源只有一个</li>
</ul>
</li>
<li><p>信号量机制实现进程同步（信号量为0）</p>
<ul>
<li><p>让本来异步并发的进程进行相互配合，有序前进</p>
</li>
<li><p><img src="https://img.mubu.com/document_image/e5250d2e-c638-406e-804a-96a2a21bc0dc-4379197.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>信号量机制实现进程同步（信号量为0）</p>
<ul>
<li><p>先V后P，V再前操作之后，P再后操作之前</p>
<p><img src="https://img.mubu.com/document_image/3c27e6a7-449f-456b-bad7-2e0725354a9e-4379197.jpg" alt="img"></p>
</li>
<li><p><img src="https://img.mubu.com/document_image/3c27e6a7-449f-456b-bad7-2e0725354a9e-4379197.jpg" alt="img"></p>
</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>生产者消费者问题</p>
<ul>
<li><p><img src="https://img.mubu.com/document_image/6a9d5069-b1e5-4034-a471-094b9354db67-4379197.jpg" alt="img"></p>
</li>
<li><p>实现互斥和实现同步的两个P操作的先后顺序，实现互斥的操作一定要在实现同步操作之后，否则会死锁</p>
</li>
</ul>
</li>
<li><p>多生产者多消费者问题（多：多类）</p>
<ul>
<li><p>（<a href="https://www.bilibili.com/video/av70156862?p=23）" target="_blank" rel="noopener">https://www.bilibili.com/video/av70156862?p=23）</a></p>
</li>
<li><p>无法总结，看视频。。。</p>
</li>
<li><p><img src="https://img.mubu.com/document_image/28f75f64-0fde-41ac-a8c6-d506c7d0bfea-4379197.jpg" alt="img"></p>
</li>
<li><p>要以事件为单位而不是以进程为单位！</p>
</li>
</ul>
</li>
<li><p>吸烟者问题</p>
</li>
<li><p>读者-写者问题</p>
<ul>
<li>读-写互斥</li>
<li>写-写互斥</li>
<li>读-读不互斥</li>
<li>重点在于在读读不互斥的前提下怎么进行解锁，怎么进行加锁，如果是第一个读程序则加锁，读完了是最后一个读程序则解锁</li>
<li>还有一个重点，count和count的变量检查和赋值无法一气呵成会导致还是无法读进程同时进行，所以需要一个互斥信号来保证对count的访问时互斥的</li>
<li>还要考虑写者不能被饿死</li>
<li>核心思想在于设置了一个计数器，而且这个计数器需要一个互斥信号量保证对计数器的访问需要互斥</li>
</ul>
</li>
<li><p>哲学家问题</p>
</li>
<li><p>管程</p>
<ul>
<li>为什么要引入管程<ul>
<li>为了程序员写程序时不需要再关注复杂的PV操作</li>
</ul>
</li>
<li>管程的定义和基本特征<ul>
<li>基本特征<ul>
<li>各外部进程/线程只能通过管程提供的特定“入口”才能访问共享数据</li>
<li>每次仅允许一个进程再管程内执行某个内部的过程</li>
</ul>
</li>
</ul>
</li>
<li>拓展1：用管程解决生产者消费者问题</li>
<li>拓展2：Java中类似于管程的机制</li>
</ul>
</li>
<li><p>死锁的概念</p>
<ul>
<li>什么是死锁<ul>
<li>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手机的资源，导致各进程都阻塞，都无法向前推进的想想</li>
</ul>
</li>
<li>进程死锁、饥饿、死循环的区别<ul>
<li>饥饿：长期得不到想要的资源</li>
<li>死循环：某种进程执行过程中一直调不出来某个循环现象</li>
<li>共同点，都无法向前推进</li>
<li>不同点<ul>
<li>死锁：至少有两个or两个以上的进程同时发生死锁（肯定不是运行态）</li>
<li>饥饿：可能只有一个进程发生饥饿（肯定不是运行态）</li>
<li>死循环：死循环是被管理者的问题，而前面两者是管理者（操作系统）的问题（可以是运行态）</li>
</ul>
</li>
</ul>
</li>
<li>死锁产生的必要条件<ul>
<li>互斥条件：只有对必须互斥使用的资源的争夺才会死锁</li>
<li>不剥夺条件：不能由其他进程强行夺走</li>
<li>请求和保持条件：保持着某些资源不放的同时，不可强行剥夺</li>
<li>循环等待条件：存在资源的循环等待连（是死锁的必要不充分条件，即循环等待未必死锁，死锁一定有循环等待）</li>
</ul>
</li>
<li>什么时候会发生死锁<ul>
<li>对不可剥夺资源的不可理分配，可能导致死锁</li>
</ul>
</li>
<li>死锁的处理策略<ul>
<li>预防：破坏四个必要条件中的一个or几个</li>
<li>避免：银行家算法</li>
<li>死锁的检测与解除，不过操作系统会负责检测出死锁的发生再进行解除</li>
</ul>
</li>
</ul>
</li>
<li><p>死锁的处理</p>
<ul>
<li>不允许死锁的发生<ul>
<li>静态策略：预防死锁<ul>
<li>破坏互斥条件<ul>
<li>SPOOLing技术</li>
<li>但是为了系统安全，必须保证有些条件是互斥的</li>
<li>缺点：可行性不高，很多时候无法破坏互斥条件</li>
</ul>
</li>
<li>破坏不剥夺条件<ul>
<li>缺点：实现发杂；剥夺资源可能导致部分工作失效；反复申请和释放导致系统开销大；可能导致饥饿</li>
<li>可剥夺也容易导致饥饿</li>
</ul>
</li>
<li>破坏请求和保持条件<ul>
<li>采用静态分配方法<ul>
<li>资源未满足，就不能投入运行，一旦投入运行，这些资源就一直归他所有</li>
<li>缺点<ul>
<li>资源利用率低，因为一旦运行，资源就一直归他所有，其次，可能导致某些进程饥饿</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>破坏循环等待条件<ul>
<li>顺序资源分配法<ul>
<li>必须按编号递增的顺序请求资源</li>
<li>缺点<ul>
<li>不方便增加新设备</li>
<li>实际使用资源顺序和编号不一致会导致资源浪费（占着茅坑不拉屎）</li>
<li>编程麻烦</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>动态策略：避免死锁<ul>
<li>什么是安全序列</li>
<li>什么是系统的不安全状态，与死锁有何联系<ul>
<li>系统处于不安全状态未必死锁，但死锁一定处于不安全状态</li>
</ul>
</li>
<li>如何避免系统进入不安全状态——银行家算法</li>
</ul>
</li>
</ul>
</li>
<li>运行死锁的发生<ul>
<li>死锁的检测和解除<ul>
<li>死锁的检测（与数据结构的联合！）<ul>
<li>两种结点<ul>
<li>进程节点：对应一个进程</li>
<li>资源节点：对应一个资源，一类资源可能有多个</li>
</ul>
</li>
<li>两种边<ul>
<li>进程节点&gt;&gt;&gt;资源节点：表示进程想申请几个资源（每条边代表一个）</li>
<li>资源节点&gt;&gt;&gt;进程节点：表示已经为进程分配了几个资源（每条边代表一个）</li>
<li>可以消除所有边==可以完全简化的==没有发生死锁==可以找到一个安全序列</li>
</ul>
</li>
</ul>
</li>
<li>死锁的解除<ul>
<li>资源剥夺法<ul>
<li>挂起死锁进程，抢占其资源</li>
<li>但是要防止被挂起的资源不会饥饿</li>
</ul>
</li>
<li>撤销进程法<ul>
<li>强制撤销部分、甚至全部死锁进程，优点简单</li>
<li>但是付出代价很大，进程运行很长时间但是功亏一篑</li>
</ul>
</li>
<li>进程回退法<ul>
<li>回退到避免死锁的地步</li>
<li>但是这要求系统记录进程的历史信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>第三章</p>
<ul>
<li><p>内存</p>
<ul>
<li>程序执行前需要先放到内存中才能被CPU处理</li>
<li>每一个地址对应一个存储单元</li>
<li>编址<ul>
<li>按字节编址，每个存储单元大小为1字节</li>
<li>按字编址，每个存储单元为1个字</li>
</ul>
</li>
<li>物理地址、逻辑地址<ul>
<li>编译时产生的指令只关心“相对地址”</li>
<li>物理地址=绝对地址</li>
<li>逻辑地址=相对地址</li>
</ul>
</li>
</ul>
</li>
<li><p>转入的三种方式</p>
<ul>
<li>绝对装入（还没由操作系统，所以这个是编译器完成的）<ul>
<li>编译、链接后得到的转入模块的指令直接就使用了绝对地址</li>
<li>不适用于多道程序</li>
</ul>
</li>
<li>静态重定位<ul>
<li>可重定位转入</li>
<li>必须分配其要求的全部内存空间、在运行期间就不能再移动、也不能再申请内存空间</li>
</ul>
</li>
<li>动态重定位<ul>
<li>动态运行时转入，把地址转换推迟到程序真正要执行时才进行，所以转入内存后所有的地址仍是逻辑地址。这种方式需要一个重定位寄存器的支持</li>
<li>重定位寄存器：存放转入模块存放的起始位置</li>
</ul>
</li>
</ul>
</li>
<li><p>链接的三种方式</p>
<ul>
<li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件，之后不再拆开</li>
<li>装入时动态链接：将各目标模块装入内存时，边转入边链接的链接方式</li>
<li>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</li>
</ul>
</li>
<li><p>内存管理的概念</p>
<ul>
<li>内存空间的分配与回收<ul>
<li>碎片<ul>
<li>内部碎片：分配给某进程地内存区域中，如果有些部分没有用上。</li>
<li>外部碎片：指内存中地某些空闲分区由于太小而难以利用</li>
</ul>
</li>
<li>连续分配管理方式<ul>
<li>单一连续分配<ul>
<li>不支持多道程序并发</li>
</ul>
</li>
<li>固定分区分配<ul>
<li>整个用户空间划分为若干个固定大小的分区，每个分区中只装入一道作业</li>
<li>分区大小相等<ul>
<li>很适用于用一台计算机控制多个对象的场合</li>
</ul>
</li>
<li>分区大小不等</li>
</ul>
</li>
<li>操作系统需要建立一个数据结构：分区说明表<ul>
<li>每个表项包括对应分区的大小、起始地址、状态</li>
<li>优点：无外部碎片</li>
<li>缺点：有内部碎片</li>
</ul>
</li>
<li>动态分区分配<ul>
<li>又称为可变分区分配</li>
<li>不会预先划分内存分区，根据进程的大小动态地建立分区</li>
<li>所采用地数据结构<ul>
<li>空闲分区表</li>
<li>空闲分区链</li>
</ul>
</li>
<li>动态分区分配算法</li>
<li>如何进行分配与回收</li>
</ul>
</li>
</ul>
</li>
<li>非连续分配管理方式</li>
</ul>
</li>
<li>内存空间的扩充<ul>
<li>覆盖技术<ul>
<li>程序分成多个段</li>
<li>常用的段放入固定区</li>
<li>不常用的段放在覆盖区</li>
<li>缺点：必须由程序员声明覆盖结构，对用户不透明</li>
</ul>
</li>
<li>交换技术<ul>
<li>当内存空间紧张的时候，将内存中某些进程暂时换入外存，把外存中某些已具备运行条件的进程换入内存</li>
<li>对换区（连续分配）速度比文件区快</li>
</ul>
</li>
<li>虚拟存储技术</li>
</ul>
</li>
<li>地址转换<ul>
<li>逻辑地址转换为物理地址（三种转入）</li>
</ul>
</li>
<li>存储保护<ul>
<li>内存空间互不干扰</li>
<li>方法一：在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界</li>
<li>方法二：采用重定位寄存器和界地址寄存器（进行越界检查）。</li>
</ul>
</li>
</ul>
</li>
<li><p>动态分区分配算法</p>
<ul>
<li><p>首次适应算法FF</p>
<ul>
<li>每次从低地址开始查找</li>
</ul>
</li>
<li><p>最佳适应算法BF</p>
<ul>
<li>空闲分区按容量递增次序链接，每次分配内存时，顺序查找空闲分区链（表），找到第一个满足的空闲分区</li>
<li>缺点：残生很多小的外部碎片</li>
</ul>
</li>
<li><p>最坏适应算法WF</p>
<ul>
<li>空闲分区按容量递减次序链接，每次分配内存时，顺序查找空闲分区链（表），找到第一个满足的空闲分区</li>
<li>优点：防止很多很小很多的外部碎片</li>
<li>缺点：如果之后有 大进程 到达就无处安放</li>
</ul>
</li>
<li><p>邻近适应算法</p>
<ul>
<li>每次都从上一次查找结束的位置开始查找，然后使用FF</li>
<li>优点：不用查找这么多</li>
</ul>
</li>
<li><p>图</p>
<p><img src="https://img.mubu.com/document_image/1cb36c6c-d101-472e-8251-dd953d64f25c-4379197.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>非连续分配管理方式（离散分配方式）</p>
<ul>
<li><p>固定分区分配：缺乏灵活性，会产生大量的内部碎片，内存利用率很低</p>
</li>
<li><p>动态分区分配：会产生很多外部碎片，虽然可以用“紧凑”技术来处理，但是“紧凑”的时间代价很高</p>
</li>
<li><p>基本分页存储管理</p>
<ul>
<li>大小相等的分区，每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每一个页框有一个编号，即“页框号”，或称“页帧号”、“内存块号”、“物理块号”，页框号从0开始</li>
<li>页对应的是线性地址的东西 而页框对应的是物理地址 是实际的存储区域</li>
<li>页号是虚拟地址的划分，指向程序中的某一页，每个页号对应一个页面号。块号是实际地址的划分，指向内存空间中某一个物理块。</li>
<li>用户进程的地址空间也分为与页框大小相等的</li>
<li>一个个区域，称为“页”或“页面”，也都从0开始</li>
<li>如何实现逻辑地址到物理地址的转换<ul>
<li>思想：模块再内存的“起始地址”+目标内存单元相对于起始位置的“偏移量”</li>
<li>计算页号and页内偏移量</li>
</ul>
</li>
<li>页表<ul>
<li>操作系统要为每个进程建立一张页表</li>
<li>一个进程对应一张页表</li>
<li>进程的每一项对应一个页表项</li>
<li>每个页表项由“页号”和“块号”组成</li>
<li>页表记录进程页面和实际存放的内存块之间的对应关系</li>
</ul>
</li>
<li>基本地址变换机构<ul>
<li>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址<ul>
<li>通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M。进程为执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把他们放到页表寄存器中。</li>
<li>步骤<ul>
<li>根据逻辑地址计算出页号、页内偏移量</li>
<li>判断页号是否越界</li>
<li>查询页表，找到页号对应的页表项，确定页面存放的内存块号</li>
<li>用内存块号和页内偏移量得到物理地址</li>
<li>访问目标内存单元</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>基本分段存储管理</p>
<ul>
<li><p>什么是分段</p>
<ul>
<li>按照自身的逻辑关系划分为若干个段</li>
<li>每段从0开始编址</li>
<li>以段为单位进行分配，每个段再内存中占据连续空间，但各段之间可以不相邻</li>
</ul>
</li>
<li><p>什么是段表</p>
<ul>
<li>段号的位数巨顶了每个进程最多可以分几个段</li>
<li>段内地址位数决定了每个段最大长度是多少</li>
</ul>
</li>
<li><p>如何实现地址变换</p>
<ul>
<li>每一个段对应了一个段表项，记录了起始位置和段的长度</li>
<li>各个段表项的长度是相同的</li>
<li>因此段号可以是隐含的，不占存储空间</li>
</ul>
</li>
<li><p>分段分页管理的对比</p>
<ul>
<li><p>查找</p>
<p><img src="https://img.mubu.com/document_image/9608743a-27cd-4bdc-97a0-898a789df1ec-4379197.jpg" alt="img"></p>
</li>
<li><p>区别，分段管理需要判断一次所需要查询的地址是否超过短长是否越界</p>
</li>
<li><p>对比</p>
<ul>
<li>页是信息的物理单位，为了提高内存利用率，对用户不可见，是系统管理的需要</li>
<li>段时信息的逻辑单位，为了更好满足用户需求，对用户可见</li>
<li>页大小固定由操作系统决定，段长度不固定由用户编写的程序决定。</li>
<li>分页用户进程地址空间时一维的，给出一个记忆符就可以表示一个地址</li>
<li>分段用户进程地址空间是二维的，程序员要给出段名还要给出段内地址</li>
<li>分段更容易实现信息的共享和保护</li>
<li>段表和页表搜寻都一样，也可以使用快表</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>具有块表的地址变换机构</p>
<ul>
<li>局部性原理<ul>
<li>时间局部性<ul>
<li>执行了某条指令，不久此指令很可能再次被执行</li>
</ul>
</li>
<li>空间局部性<ul>
<li>访问了某个存储单元，不久后，其附件的单元有可能被访问</li>
</ul>
</li>
</ul>
</li>
<li>什么是快表（TLB）<ul>
<li>通过以上的原理，产生了快表</li>
</ul>
</li>
<li>引入块表后，地址变换的过程<ul>
<li>快表和慢表不能同时查询</li>
<li>快表和慢表可以同时查询</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>两级页表</p>
<ul>
<li><p>单级页表存在的问题</p>
<ul>
<li>所有的页表项都需连续存放，当页表很大的时候，需要占用很大的连续的页框</li>
<li>进程在一段时间可能只需要访问几个特定的页面就可以了，没必要让整个页表常驻内存</li>
<li>此时就需要再为离散分配的页表再建立一张页表，称为页目录表or外层页表or顶层页表</li>
</ul>
</li>
<li><p>若采用多级页表机制，则各级页表的大小不能 超过一个页面</p>
<p><img src="https://img.mubu.com/document_image/bcb39d24-bdbb-43da-8489-b89256081b54-4379197.jpg" alt="img"></p>
</li>
<li><p>N级页表访存次数分析（没有快表结构）</p>
<ul>
<li>需要N+1次访存</li>
</ul>
</li>
</ul>
</li>
<li><p>段页式管理方式</p>
<ul>
<li><p>分页、分段管理方式中最大的优缺点</p>
<ul>
<li>单纯分页不会产生外部碎片，但是不利于共享和保护</li>
<li>单纯分段会产生外部碎片，但是利于共享和保护</li>
</ul>
</li>
<li><p>分段+分页的结合——段页式管理方式</p>
<p><img src="https://img.mubu.com/document_image/36cb80c0-f86f-4e50-a883-b83e6e702b04-4379197.jpg" alt="img"></p>
</li>
<li><p>段表、页表</p>
<ul>
<li>段表存放的就是：段号、（隐）页表长度、页表存放块号</li>
</ul>
</li>
<li><p>如何实现地址变换</p>
<p><img src="https://img.mubu.com/document_image/be33a6c5-d117-4af9-a553-6702ee98ed62-4379197.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>虚拟内存的基本概念</p>
<ul>
<li><p>传统存储管理方式的特征、缺点</p>
<ul>
<li>很多暂时用不到的数据也会长期占用内存，导致内存利用率不高</li>
<li>一次性：作业必须一次性全部转入内存后才能开始运行：1、作业太大（GTA5）不能全部转入内存，导致大作业无法运行。2、当大量作业要求运行时，内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。</li>
<li>驻留性：一旦作业被转入内存，就会一直驻留在内存中。</li>
</ul>
</li>
<li><p>局部性原理</p>
<p><img src="https://img.mubu.com/document_image/bb9bb2bc-85c2-4e47-af47-222ffe82df03-4379197.jpg" alt="img"></p>
<ul>
<li><p>时间局部性</p>
<ul>
<li>如果执行了程序中的某条指令，那么不久后这条指令很可能再次运行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）</li>
</ul>
</li>
<li><p>空间局部性</p>
<ul>
<li>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元页很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</li>
</ul>
</li>
<li><p><img src="https://img.mubu.com/document_image/c28e5560-8b0f-40b2-97ca-4fac12625654-4379197.jpg" alt="img"></p>
</li>
<li><p>高速缓存技术</p>
<p><img src="https://img.mubu.com/document_image/24dbb90c-d226-4a3a-9903-c2e51aad1e19-4379197.jpg" alt="img"></p>
<ul>
<li>必须要建立在离散分配的内存管理方式基础之上</li>
<li>内存不够，页面置换</li>
<li>信息不在，请求调页</li>
<li>实现<ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段也式存储管理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>虚拟内存的定义和特征</p>
</li>
<li><p>如何实现虚拟内存技术</p>
</li>
</ul>
</li>
<li><p>请求分页管理方式</p>
<ul>
<li>相对于分页管理方式增加了两个功能<ul>
<li>操作系统需要提供请求调页功能，将缺失页面从外存调入内存</li>
<li>当页面内存不够用的时候，将内存中暂时用不到的信息换出到外存</li>
<li></li>
</ul>
</li>
<li>页表机制<ul>
<li>请求分页页表</li>
<li>页号（隐）（同分页管理）</li>
<li>内存块号（同分页管理）</li>
<li>状态位</li>
<li>访问字段</li>
<li>修改位</li>
<li>外存地址</li>
</ul>
</li>
<li>缺页中断机构（属于内中断，属于故障）<ul>
<li>当页面不在内存时，产生缺页中断</li>
<li>此时缺页进程阻塞</li>
<li>调页完成后才将其唤醒</li>
<li>有空闲，直接分配一个空闲块</li>
<li>没有空闲块，需要页面置换算法选择一个页面淘汰，如果被修改过，则需要写回外存</li>
<li>如果某个页面被换出外存，那么一定要在快表中删除</li>
</ul>
</li>
<li>地址变换机构</li>
</ul>
</li>
<li><p>页面置换算法</p>
<ul>
<li><p>应该追求更少的缺页率</p>
</li>
<li><p>最佳置换算法（OPT OPTimal replacement）</p>
<ul>
<li>以后永远不适用的页面</li>
<li>or在最长时间内不再被访问的页面</li>
<li>理想化算法，无法实现，因为没法预判之后需要用到的页面</li>
</ul>
</li>
<li><p>先进先出置换算法（FIFO）</p>
<ul>
<li>每次选择淘汰的页面是最早进入内存的页面</li>
<li>发生belady异常——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象</li>
</ul>
</li>
<li><p>最近最久未使用置换算法（LRU Least recently used）</p>
<ul>
<li>访问字段记录页面自上次被访问以来所经历的时间t</li>
<li>当要淘汰一个页面的时候，选择t最大的</li>
<li>享内好，但是实现困难，开销大，需要专门硬件</li>
</ul>
</li>
<li><p>时钟置换算法（CLOCK）or 最近未用算法（NRU，Not Recently Used）</p>
<ul>
<li>最多进行两轮扫描</li>
<li>略</li>
</ul>
</li>
<li><p>改进的时钟置换算法</p>
<ul>
<li><p>最多进行四轮扫描</p>
</li>
<li><p>相对于时钟置换算法，（因为只有被淘汰的页面被修改过时，才需要写回外存），所以在其他条件都相同的时候，优先淘汰没有修改过的页面，所以增加了修改位。（访问位，修改位）</p>
</li>
<li><p>找0，0不修改——找0，1修改访问位——再找0，0不修改——再找0，1用于替换。</p>
<p><img src="https://img.mubu.com/document_image/310b0bb2-f6d0-46e9-aa06-2b87e4b8c727-4379197.jpg" alt="img"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>页面分配策略</p>
<ul>
<li>驻留集<ul>
<li>指请求分页存储管理中给进程分配的内存块集合</li>
<li>驻留集太小，会导致频繁缺页</li>
<li>驻留集太大，会导致多道程序并发度下降</li>
<li>固定分配<ul>
<li>刚刚开始决定就不可以改变了</li>
</ul>
</li>
<li>可变分配<ul>
<li>运行中可以视情况增加or减少</li>
</ul>
</li>
</ul>
</li>
<li>页面分配、置换策略<ul>
<li>固定分配局部置换<ul>
<li>进程运行前就分配一定的物理块，缺页时只能换出进程自己的某一页</li>
</ul>
</li>
<li>可变分配全局置换<ul>
<li>只要缺页就分配新物理块，可能来自空闲物理块，也可能需换出别的进程页面，这样会导致被选中的进程拥有的物理块会减少，缺页率会增加</li>
</ul>
</li>
<li>可变分配局部置换<ul>
<li>频繁缺页的进程，多分配一些物理块；缺页率很低的进程，回收一些物理块，直到缺页合适</li>
</ul>
</li>
</ul>
</li>
<li>调入页面的时机<ul>
<li>预调页策略<ul>
<li>预测不久之后可能访问的页面，但是预测成功率只有50%，故此策略主要用于进程的首次调入，由程序员指出应该调入哪些部分</li>
</ul>
</li>
<li>请求调页策略<ul>
<li>进程再运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面页一定会被访问，但是每次只能调一页，所以I/O开销大</li>
</ul>
</li>
</ul>
</li>
<li>从何处调页<ul>
<li>对换区：快，文件区：慢</li>
<li>对换区足够大：运行将数据从文件区复制到对换区，之后所有的页面调入、调出都是在内存与对换区之间进行</li>
<li>对换区不够大：不会修改的数据从文件区调入，会修改的数据调出到对换区，再次使用从对换区调入</li>
<li>UNIX方式：第一次使用的页面都从文件区调入；调出的页面都写回对换区，再次使用就从对换区调入<ul>
<li>Ubuntu的Swap分区，自己装Ubuntu可见所推荐的Swap分区要是自己运行内存的两倍</li>
</ul>
</li>
</ul>
</li>
<li>抖动（颠簸）现象<ul>
<li>刚刚换出的页面马上又要换入内存</li>
<li>这种频繁的页面调度行为被称为抖动，或颠簸</li>
<li>产生抖动的原因时进程频繁访问的页面数高于可用的物理块数（分配给进程的物理块不够）</li>
</ul>
</li>
<li>工作集<ul>
<li>指某段时间间隔里，进程实际访问页面的集合</li>
<li>驻留集一般不能小于工作集的大小，否则回产生抖动</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>第四章</p>
<ul>
<li><p>文件的属性</p>
<ul>
<li>文件名</li>
<li>类型</li>
<li>位置<ul>
<li>文件存放的路径（让用户使用）</li>
<li>外存中的地址（操作系统使用，对用户不可见）</li>
</ul>
</li>
<li>大小</li>
<li>创建时间、上次修改时间、文件所有者信息</li>
<li>保护信息</li>
</ul>
</li>
<li><p>向上提供的几个最基本的功能</p>
<ul>
<li>创建文件</li>
<li>删除文件</li>
<li>读文件</li>
<li>写文件</li>
<li>打开文件</li>
<li>关闭文件</li>
</ul>
</li>
<li><p>文件的逻辑结构</p>
<ul>
<li><p>文件的 逻辑结构 是指在用户看来，物理结构 指的是操作系统看来</p>
</li>
<li><p>无结构文件</p>
</li>
<li><p>有结构文件</p>
<p>又称为“记式文件”</p>
<ul>
<li>顺序文件<ul>
<li>链式存储<ul>
<li>无论式定长/可变长记录，都无法实现随机存储，每次智能从第一个记录开始依次往后查找</li>
<li>顺序存储<ul>
<li>可变长记录<ul>
<li>无法实现随机存取。每次只能从第一个记录开始依次往后查找</li>
</ul>
</li>
<li>定长记录<ul>
<li>可实现随机存取。记录长度为L，则第i个记录存放的相对位置是i*L</li>
<li>若采用串结构，无法快速找到某关键字对应的记录</li>
<li>若采用顺序结构，可以快速找到某关键字对应的记录（如折半查找）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>串结构<ul>
<li>纪录之间的顺序与关键字无关</li>
</ul>
</li>
<li>顺序结构<ul>
<li>记录之间的顺序按关键字顺序排列</li>
</ul>
</li>
</ul>
</li>
<li>索引文件<ul>
<li>本身是定长记录的顺序文件，一个索引表项就是一条定长记录，因此索引文件可支持随机存取</li>
<li>建立一张索引表，每个记录对应一个表项。各记录不用保持顺序，方便增加/删除记录</li>
<li>若索引表按关键字顺序排序，则可支持快速检索</li>
<li>解决了顺序文件不方便增/删记录的问题，同时让不定长记录的文件实现了随机存取。但索引表可能占用很多空间</li>
</ul>
</li>
<li>索引顺序文件<ul>
<li>一组记录对应一个索引表项</li>
<li>检索记录时想顺序查找索引表，找到分组，在顺序查找分组</li>
<li>但记录过多时，可建立多级索引表</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>文件目录</p>
<ul>
<li>文件控制块（实现文件目录的关键数据结构）FCB<ul>
<li>一个FCB就是一个文件目录项，多个FCB组成文件目录</li>
<li>对目录的操作：搜索、创建文件、删除文件、显示文件、修改文件</li>
<li>最重要，最基本的还是文件名&gt;&gt;文件存放的物理地址的映射</li>
</ul>
</li>
<li>目录结构<ul>
<li>单级目录结构<ul>
<li>一个系统只有一张目录表，不允许重名</li>
</ul>
</li>
<li>两级目录结构<ul>
<li>不同用户的文件可以重名，但不能对文件进行分类</li>
</ul>
</li>
<li>多级目录结构（树形目录结构）<ul>
<li>不同目录下可以重名，可以对文件进行分类，不方便文件共享</li>
<li>系统根据“文件路径”找到目标文件</li>
<li>从根目录出发的路径是“绝对路径”</li>
<li>从“当前目录”出发的是“相对路径”</li>
</ul>
</li>
<li>无环图目录结构<ul>
<li>可以用不同的文件名指向同一文件，甚至可以指向同一个目录（共享同一目录下的所有内容）</li>
<li>在树形目录结构的基础上，增加一些指向同意节点的有向边，使整个目录成为一个有向无环图</li>
<li>在共享节点设置一个共享计数器，计数器为0时，才真正删除该结点</li>
</ul>
</li>
</ul>
</li>
<li>索引结点（对文件控制块的优化）<ul>
<li>除了文件名之外的所有信息都放到索引结点中，每个文件对应一个索引结点</li>
<li>目录项只包含文件名、索引结点指针，因此每个目录项的长度大幅度减少</li>
<li>由于目录项长度减少，因此每个磁盘块可以存放更多的目录项，因此检索文件时磁盘I/O的次数就少了很多</li>
</ul>
</li>
</ul>
</li>
<li><p>文件的物理结构</p>
<ul>
<li><p>顺序分配</p>
<ul>
<li>文件分配必须是连续的磁盘块</li>
<li>目录项内容<ul>
<li>起始块号、文件长度</li>
</ul>
</li>
<li>优点<ul>
<li>顺序存取速度快，支持随机访问</li>
</ul>
</li>
<li>缺点<ul>
<li>会产生碎片，不利于文件拓展</li>
</ul>
</li>
</ul>
</li>
<li><p>链接分配</p>
<ul>
<li><p>隐式链接</p>
<p>*Next指向下一个 下一个块</p>
<ul>
<li>除文件的组后一个块之外，每个盘块中都存有指向下一个盘块的指针</li>
<li>目录项内容<ul>
<li>起始块号、结束块号</li>
</ul>
</li>
<li>优点<ul>
<li>可以解决碎片问题，外存利用率高，文件拓展实现方便</li>
</ul>
</li>
<li>缺点<ul>
<li>只支持顺序访问，不支持随机访问</li>
</ul>
</li>
</ul>
</li>
<li><p>显式链接（链式分配）</p>
<ul>
<li>建立一张文件分配表（FAT），显示记录盘块的先后关系（开机后FAT常驻内存）</li>
<li>目录项内容<ul>
<li>起始块号</li>
</ul>
</li>
<li>优点<ul>
<li>除了拥有隐式链接的优点之外，还可以通过查询内存中的FAT实现随机访问</li>
</ul>
</li>
<li>缺点<ul>
<li>FAT需要占用一定的存储空间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>索引分配</p>
<ul>
<li>为文件数据块建立索引表。若文件太大，可采用链接方案、多层索引、混合索引</li>
<li>目录项内容<ul>
<li>链接方案记录的是第一i个索引块的块号，多层/混合索引记录的是顶级索引块的块号</li>
</ul>
</li>
<li>优点<ul>
<li>支持随机访问，易于实现文件的拓展</li>
</ul>
</li>
<li>缺点<ul>
<li>索引表占用一定的存储空间。访问数据块前需要先读入索引块。若采用链接方案，查找索引块可能需要很多次读磁盘的操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>文件存储空间管理</p>
<ul>
<li>存储空间的划分与初始化<ul>
<li>文件卷（逻辑卷）的概</li>
<li>目录区与文件区</li>
<li>目录包含文件目录、空闲表、位示图、超级块等用于文件管理的数据</li>
</ul>
</li>
<li>几种管理方法<ul>
<li>空闲表法<ul>
<li>空闲区中记录每个连续空闲区的起始盘块号、盘块数</li>
<li>分配时可以采用首次适应、最佳适应等策略；回收时注意表项的合并问题</li>
</ul>
</li>
<li>空闲链表法<ul>
<li>空闲盘块链<ul>
<li>以盘块为单位组成一条空闲链</li>
</ul>
</li>
<li>空闲盘区链<ul>
<li>以盘区为单位组成一条空闲链</li>
<li>分配时可以采用首次适应、最佳适应等策略；回收时注意表项的合并问题</li>
</ul>
</li>
</ul>
</li>
<li>位示图法<ul>
<li>一个二进制对于一个盘块。（字号，位号）或（行号，列号）与盘块号一一对应</li>
<li>重要考点：要能够自己推出盘块号到（字号，位号）之间的呼唤公式</li>
<li>需要注意的题目条件<ul>
<li>二进制位0/1到底哪个代表空闲，哪个代表不空闲</li>
<li>字号、位号、盘块号到底是从0开始还是1开始</li>
</ul>
</li>
</ul>
</li>
<li>成组链接法<ul>
<li>UNIX采用的策略，适合大型文件系统。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>文件的基本操作</p>
<ul>
<li>创建文件（create系统调用）<ul>
<li>分配外存空间，创建目录项</li>
</ul>
</li>
<li>删除文件（delete系统调用）<ul>
<li>回收外存空间，删除目录项</li>
</ul>
</li>
<li>读文件（read系统调用）<ul>
<li>根据读指针、读入数据量、内存位置 将文件数据从外存读入内存</li>
</ul>
</li>
<li>写文件（write系统调用）<ul>
<li>根据写指针、写出数据量、内存位置 将文件数据从从内存写出外存</li>
</ul>
</li>
<li>打开文件（open系统调用）<ul>
<li>将目录项中的信息赋值到内存中打开文件表中并将打开文件表的索引号返回给用户</li>
<li>打开文件之后，对文件的操作不再需要每次都查询目录，可以根据内存中的打开文件表进行操作</li>
<li>每个进程都有自己的打开文件表，系统也有一张总的打开文件表</li>
<li>经常打开文件表中特有的属性：读写指针、访问权限（只读？读写?）</li>
<li>系统打开文件表中特有的属性：打开计数器（有多少个进程打开了该文件）</li>
</ul>
</li>
<li>关闭文件（close系统调用）<ul>
<li>将进程打开文件表中的相应表项删除</li>
<li>系统打开文件表的打开计数器减1，若打开计数器为0，则删除系统表的表项</li>
</ul>
</li>
</ul>
</li>
<li><p>文件共享</p>
<ul>
<li><p>基于索引结点的共享方式（硬链接）</p>
<p>直接指向索引结点</p>
<ul>
<li>各个用户的目录项指向同一个索引结点</li>
<li>索引结点中需要有链接计数count</li>
<li>某用户想删除文件时，只是删除该用户的目录项，且count–</li>
<li>只有count==0时才能真正删除文件数据和索引结点，否则会导致指针悬空</li>
</ul>
</li>
<li><p>基于符号链的共享方式（软链接）</p>
<p>快捷方式</p>
<ul>
<li>在一个Link型的文件中记录共享文件的存放路径（Windows快捷方式）</li>
<li>操作系统根据路径一层一层查找目录，最终找到共享文件</li>
<li>即使软连接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径区查找共享文件会失败（找不到对应目录项）</li>
<li>由于用软连接的方式访问共享文件时要查询多级目录，会有多次磁盘I/O，因此用软连接访问速度比硬链接要慢</li>
</ul>
</li>
</ul>
</li>
<li><p>文件保护</p>
<ul>
<li>口令保护<ul>
<li>为文件设置一个“口令”，用户想要访问文件时需要提供口令，由系统验证口令是否正确</li>
<li>实现开销小，但“口令”一般存放在FCB或索引结点中（也就是存放在系统中）因此不太安全</li>
</ul>
</li>
<li>加密保护<ul>
<li>用一个“密码”对文件加密，用户想要访问文件时，需要提供相同的“密码”才能正确的解密</li>
<li>安全性高，但加密/解密需要耗费一定的时间（Eg：异或加密）</li>
</ul>
</li>
<li>访问控制<ul>
<li>用一个访问控制表（ACL）记录各个用户（或各组用户）对文件的访问权限</li>
<li>对文件的访问类型可以分为：读/写/执行/删除 等</li>
<li>实现灵活，可以实现复杂的文件保护功能</li>
</ul>
</li>
</ul>
</li>
<li><p>文件系统的层次结构</p>
<ul>
<li><p>例子记忆</p>
<p><img src="https://img.mubu.com/document_image/8da6133a-f2d8-4ccd-b287-247217e4578d-4379197.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>磁盘的结构</p>
<ul>
<li>磁盘、磁道、扇区的概念<ul>
<li>磁盘由表面涂有磁性物质的圆形盘片组成</li>
<li>每个盘片被划分为一个个磁道，每个磁道又划分为一个个扇区</li>
</ul>
</li>
<li>如何在磁盘中读/写数据<ul>
<li>磁头移动到目标位置，盘片旋转，对应扇区划过磁道才能完成读/写</li>
</ul>
</li>
<li>盘面、柱面的概念<ul>
<li>磁盘有多个盘片“摞”起来，每个盘面有两个盘面</li>
<li>所有盘面中相对位置相同的磁道组成柱面</li>
</ul>
</li>
<li>磁盘的物理地址<ul>
<li>（柱面号，盘面号，扇区号）</li>
</ul>
</li>
<li>磁盘的分类<ul>
<li>根据磁头是否可移动<ul>
<li>固定头磁盘（每个磁道有一个磁头）</li>
<li>移动头磁盘（每个盘面只有一个磁头）</li>
</ul>
</li>
<li>根据盘片是否可 更换<ul>
<li>固定盘磁盘</li>
<li>可换盘磁盘</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>磁盘调度算法</p>
<ul>
<li><p>一次磁盘读/写操作所需要的时间</p>
<ul>
<li><p>寻找时间</p>
<p><img src="https://img.mubu.com/document_image/794c32db-97a3-46b3-98ec-db1e7c5dbf6e-4379197.jpg" alt="img"></p>
</li>
<li><p>延迟时间</p>
<p><img src="https://img.mubu.com/document_image/53c2225b-6e86-4b61-9ab3-ce1cf6292ecf-4379197.jpg" alt="img"></p>
</li>
<li><p>传输时间</p>
<p><img src="https://img.mubu.com/document_image/a1a683b4-5cc0-4615-8ade-536e05f53bc5-4379197.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>磁盘调度算法（其他的时间都是硬件上的无法优化，所以只能优化寻找时间即磁盘调度算法）</p>
<ul>
<li>先来先服务（FCFS）<ul>
<li>按访问请求到达的先后顺序进行处理</li>
</ul>
</li>
<li>最短寻找时间优先（SSTF）（贪心算法的思想）<ul>
<li>每次都优先响应距离磁头最近的磁道访问请求</li>
<li>贪心算法的思想，能保证眼前最优，但是无法保证总的寻道时间最短</li>
<li>缺点：可能导致饥饿</li>
</ul>
</li>
<li>扫描算法（电梯算法、SCAN）<ul>
<li>只有磁头移动到最边缘的磁道时才可以改变磁头的移动方向</li>
<li>缺点：对各个位置磁道的相应频率不平均</li>
</ul>
</li>
<li>循环扫描算法（C-SCAN）<ul>
<li>只有磁头朝某个方向移动时才会响应请求，移动到边缘后立即让磁头返回起点，返回途中不响应任何请求</li>
</ul>
</li>
<li>LOOK算法<ul>
<li>SCAN算法的改进，只要在磁头移动方向上不再有请求，就立即改变磁头方向</li>
</ul>
</li>
<li>C-LOOK算法<ul>
<li>C-SCAN算法的改进，只要在磁头移动方向上不再有请求，就立即让磁头返回</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>减少延迟时间的反复</p>
<ul>
<li>交替编号<ul>
<li>具体做法：让编号相邻的扇区在物理上不相邻</li>
<li>原理：读取完一个扇区后需要一段时间处理才可以继续读入下一个扇区</li>
</ul>
</li>
<li>错位命名<ul>
<li>具体做法：让相邻盘面的扇区编号“错位”</li>
<li>原理：与“交替编号”的原理相同。“错位命名法”可以降低延迟时间</li>
</ul>
</li>
<li>磁盘地址结构的设计<ul>
<li>理解为什么要用（柱面号，盘面号，扇区号）的结构</li>
<li>理解为什么不用（盘面号，柱面号，扇区号）的结构</li>
<li>原因：在读取地址连续的磁盘块时，前者更不需要移动磁头</li>
</ul>
</li>
</ul>
</li>
<li><p>磁盘管理</p>
<ul>
<li>磁盘初始化<ul>
<li>低级格式化/物理格式化：划分扇区</li>
<li>磁盘分区（C盘、D盘、E盘）</li>
<li>逻辑格式化：建立文件系统（建立根目录文件、建立用于存储空间管理的数据结构）</li>
</ul>
</li>
<li>引导块<ul>
<li>计算机启动时需要运行初始化程序（自举程序）来完成初始化</li>
<li>ROM中存放很小的自举装入程序</li>
<li>完整的自举程序存放在初始块（引导块）中</li>
</ul>
</li>
<li>坏块的处理<ul>
<li>简单的磁盘：逻辑格式化时将坏块标记出来</li>
<li>复炸的磁盘：磁盘控制器维护一个坏块链，并管理备用扇区</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>第五章</p>
<ul>
<li><p>I/O设备的基本概念和分类</p>
<ul>
<li>什么是I/O设备<ul>
<li>将数据Input/Output计算机的外部设备</li>
</ul>
</li>
<li>按使用特性分类<ul>
<li>人机交互类外部设备</li>
<li>存储设备</li>
<li>网络通信设备</li>
</ul>
</li>
<li>按传输速率分类<ul>
<li>低速设备</li>
<li>中速设备</li>
<li>高速设备</li>
</ul>
</li>
<li>按信息交换的单位分类<ul>
<li>块设备（传输快，可寻址）</li>
<li>字符设备（传输慢，不可寻址，采用中断驱动方式）</li>
</ul>
</li>
</ul>
</li>
<li><p>I/O控制器</p>
<ul>
<li>主要功能<ul>
<li>接收和识别CPU发出的指令（要有控制寄存器）</li>
<li>向CPU报告设备的状态（要有状态寄存器）</li>
<li>数据交换（要有数据寄存器，暂存输入/输出的数据）</li>
<li>地址识别（由I/O逻辑实现）</li>
</ul>
</li>
<li>组成<ul>
<li>CPU与控制器之间的接口（实现控制器与CPU之间的通信）</li>
<li>I/O逻辑（负责识别CPU发出的命令，并向设备发出命令）</li>
<li>控制器与设备之间的接口（实现控制器与设备之间的通信</li>
</ul>
</li>
<li>两种寄存器编址方式<ul>
<li>内存映射I/O<ul>
<li>控制器中的寄存器与内存统一编制</li>
<li>可以采用对内存进行操作的指令来对控制器进行操作</li>
</ul>
</li>
<li>寄存器独立编址<ul>
<li>控制器中的寄存器独立编址</li>
<li>需要设置专门的指令来操作控制器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>I/O控制方式</p>
<ul>
<li><p>程序直接控制方式</p>
<p>就像你不知道快递到没到，一直去菜鸟驿站去看</p>
<ul>
<li>完成一次读写/写的过程：CPU发出I/O命令后需要不断轮询</li>
<li>CPU干预频率：极高</li>
<li>每次I/O的数据传输单位：字</li>
<li>数据流向：<ul>
<li>设备-&gt;CPU-&gt;内存</li>
<li>内存-&gt;CPU-&gt;设备</li>
</ul>
</li>
</ul>
</li>
<li><p>中断驱动方式</p>
<p>但菜鸟驿站收到你的快递，给你发取货码，然后你再下楼取</p>
<ul>
<li>完成一次读写/写的过程：CPU发出I/O命令后可以做其他事，本次I/O完成后设备控制器发出中断信号</li>
<li>CPU干预频率：高</li>
<li>每次I/O的数据传输单位：字</li>
<li>数据流向：<ul>
<li>设备-&gt;CPU-&gt;内存</li>
<li>内存-&gt;CPU-&gt;设备</li>
</ul>
</li>
</ul>
</li>
<li><p>DMA方式（Direct Memory Access，直接存储器存取）</p>
<p>直接把快递送到家门口（不需要经过菜鸟驿站“CPU”）</p>
<ul>
<li>完成一次读写/写的过程：CPU发出I/O命令后可以做其他事，本次I/O完成后DMA控制器发出中断信号</li>
<li>CPU干预频率：中</li>
<li>每次I/O的数据传输单位：块</li>
<li>数据流向：<ul>
<li>设备-&gt;内存</li>
<li>内存-&gt;设备</li>
</ul>
</li>
</ul>
</li>
<li><p>通道控制方式</p>
<p>直接把你双十一买的一堆快递送到家门口，然后再开门取</p>
<ul>
<li>完成一次读写/写的过程：CPU发出I/O命令后可以做其他事。通道会执行通道程序以完成I/O，完成后通道向CPU发出中断信号</li>
<li>CPU干预频率：低</li>
<li>每次I/O的数据传输单位：一组块</li>
<li>数据流向：<ul>
<li>设备-&gt;内存</li>
<li>内存-&gt;设备</li>
</ul>
</li>
</ul>
</li>
<li><p>总结and优缺点</p>
<ul>
<li>每一个阶段的优点都是解决了上一阶段的最大缺点。总体来说，整个发展过程就是要尽量减少CPU对I/O过程的干预，把CPU从繁杂的I/O控制事物中解脱出来，以便更多地取完成数据处理任务</li>
<li>通道=弱鸡版CPU</li>
<li>通道程序=任务清单</li>
<li>一个通道可以控制多个I/O控制器，一个I/O控制器控制多个I/O设备</li>
</ul>
</li>
</ul>
</li>
<li><p>I/O核心子系统</p>
<ul>
<li>设备独立性软件</li>
<li>设备驱动程序</li>
<li>中断处理程序</li>
</ul>
</li>
<li><p>假脱机技术（SPOOLing）</p>
<ul>
<li>脱机技术<ul>
<li>“脱机”<ul>
<li>脱机主机</li>
</ul>
</li>
<li>外围控制机+跟高速的设备——磁带</li>
<li>作用：缓解设备与CPU的速度矛盾，实现预输入、缓输出</li>
</ul>
</li>
<li>假脱机技术<ul>
<li>又叫SPOOLing技术，用软件的方式模拟脱机技术</li>
<li>输入井和输出井——模拟脱机输入/输出时的磁带</li>
<li>输入进程和输出进程——模拟脱机输入/输出时的外围控制机</li>
<li>输入缓冲区和输出缓冲区——内存中的缓冲区，输入、输出时的“中转站”</li>
</ul>
</li>
<li>共享打印机<ul>
<li>用SPOOLing技术将独占式打印机“模拟”成共享打印机</li>
</ul>
</li>
</ul>
</li>
<li><p>设备的分配与回收</p>
<ul>
<li>设备分配日是应考虑的因素<ul>
<li>设备的固有属性<ul>
<li>独占设备、共享设备、虚拟设备</li>
</ul>
</li>
<li>设备分配算法<ul>
<li>先来先服务</li>
<li>优先级高者优先</li>
<li>短任务优先</li>
<li>……</li>
</ul>
</li>
<li>设备分配中的安全性<ul>
<li>安全分配方式</li>
<li>不安全分配方式</li>
</ul>
</li>
</ul>
</li>
<li>静态分配与动态分配<ul>
<li>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源</li>
<li>动态分配：进程运行过程中动态申请设备资源</li>
</ul>
</li>
<li>设备分配管理中的数据结构<ul>
<li>设备控制表（DCT）每个设备对应一张DCT。关键字段：类型/标识符/状态/指向COCT的指针/等待队列指针</li>
<li>控制器控制表（COCT）每个控制器对应一张COCT。关键字段：状态/指向CHCT的指针/等待队列的指针</li>
<li>通道控制表（CHCT）每个控制器对应一张CHCT。关键字段：状态/等待队列指针</li>
<li>系统设备表（SDT）记录整个系统中所有设备的情况，每个设备对应一个表目。关键字段：设备类型/标识符/DCT/驱动程序入口</li>
</ul>
</li>
<li>设备分配的步骤<ul>
<li>步骤<ul>
<li>根据进程请求的物理设备名找到SDT</li>
<li>根据SDT找到DCT并分配设备</li>
<li>根据DCT找到COCT并分配控制器</li>
<li>根据COCT找到CHCT并分配通道</li>
</ul>
</li>
<li>注意<ul>
<li>只有设备、控制器、通道，三者都分配成功时，这次设备分配才算成功，之后便可启动I/O设备进行数据传送</li>
</ul>
</li>
<li>缺点<ul>
<li>用户编程必须使用“物理设备名”，若换了一个物理设备，则程序无法运行。</li>
<li>若进程真正忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li>
</ul>
</li>
</ul>
</li>
<li>设备分配步骤的改进方法<ul>
<li>用户编程时使用逻辑设备名申请设备，操作系统负责实现从逻辑设备名到物理设备名的映射（通过LUT）</li>
<li>逻辑设备的设置问题<ul>
<li>整个系统只有一张LUT：各用户所用的逻辑设备名不允许重复</li>
<li>每个用户一张LUT：各个用户的逻辑设备名可重复</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>缓冲区管理</p>
<ul>
<li>什么是缓冲区？有什么作用？<ul>
<li>一般利用内存作为缓冲区</li>
<li>作用<ul>
<li>缓和CPU与I/O设备之间速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</li>
<li>解决数据粒度不匹配的问题</li>
<li>提高CPU与I/O设备之间的并行性</li>
</ul>
</li>
</ul>
</li>
<li>单缓冲<ul>
<li>设备——（T）——缓冲区——（M）——工作区——（C）——处理</li>
<li>处理一块数据平均耗时Max(C,T)+M</li>
<li>分析问题的初始状态：工作区满，缓冲区空</li>
</ul>
</li>
<li>双缓冲<ul>
<li>处理一块数据平均耗时Max(C,T+M)</li>
<li>分析问题的初始状态：工作区空，一个缓冲区满，另一个缓冲区空</li>
</ul>
</li>
<li>循环缓冲<ul>
<li>多个缓冲区链接成循环队列，in指针指向第一个空缓冲区，out指针指向第一个满缓冲区</li>
</ul>
</li>
<li>缓冲池<ul>
<li>三个队列：空缓冲队列、输入队列、输出队列</li>
<li>四种工作缓冲区<ul>
<li>用于收容输入数据的工作缓冲区、用于提取输入数据的工作缓冲区</li>
<li>用于收容输出数据的工作缓冲区、用于提取输出数据的工作缓冲区</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" rel="tag"># 理论基础</a>
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2019/11/10/S9%E5%89%8D%E5%A4%95%E5%B0%8F%E8%AE%B0/" rel="next" title="S9前夕小记">
                  <i class="fa fa-chevron-left"></i> S9前夕小记
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2019/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/" rel="prev" title="数据结构总结">
                  数据结构总结 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="执灬念"
    src="/head/avatar.JPG">
  <p class="site-author-name" itemprop="name">执灬念</p>
  <div class="site-description" itemprop="description">没有一颗心，会因为追求梦想而受伤。当你真心渴望某样东西时，整个宇宙都会来帮忙。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">执灬念</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

</body>
</html>
